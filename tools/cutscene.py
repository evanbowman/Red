from PIL import Image
import sys

# A little script that I threw together for encoding cutscene gifs in a format
# that the engine for Red expects. Outputs three files, one containing the
# encoded map data, one containing tile texture data, and one containing a
# table of tile texture sizes, for indexing into the tile texture data.


tile_counts = []
frame = 0


fname = sys.argv[1]
fname_prefix = fname.split(".")[0]


texture_data_file_name = fname_prefix + "_" + "texture_data.asm"
map_data_file_name = fname_prefix + "_" + "map_data.asm"
tile_counts_file_name = fname_prefix + "_" + "texture_offsets.asm"


im = Image.open(fname)


with open(texture_data_file_name, "w") as td_file:
    td_file.write(";;; Generated by cutscene.py\n")
    td_file.write("cutscene_" + fname_prefix + "_tile_textures::\n")


with open(map_data_file_name, "w") as map_file:
    map_file.write(";;; Generated by cutscene.py\n")
    map_file.write("cutscene_" + fname_prefix + "_map_data::\n")


while True:
    try:
        im.seek(frame)
        print("processing frame {}".format(frame))
    except EOFError:
        # I don't know how to determine where a PIL gif file in python ends,
        # other than triggering an out of bounds exception. At time of writing,
        # there is no simple alternative, according to stackoverflow.
        with open(tile_counts_file_name, "w") as tc_file:
            tc_file.write(";;; Generated by cutscene.py\n")
            tc_file.write("cutscene_" + fname_prefix + "_texture_offsets::\n")
            tc_file.write("DB      ")
            accum = 0
            for count in tile_counts:
                tc_file.write('${0:0{1}X}, '.format(accum & 0x00ff, 2))
                tc_file.write('${0:0{1}X}, '.format((accum & 0xff00) >> 8, 2))
                accum += count * 16 # 16 bytes per tile texture

        print("texture bytes used: {}".format(accum))
        print("frame map bytes used: {}".format(576 * (frame - 1)))

        print("end of gif")
        sys.exit(1)


    def chunk(seq, size, groupByList=True):
        func = tuple
        if groupByList:
            func = list
        return [func(seq[i:i + size]) for i in range(0, len(seq), size)]


    def getPaletteInRgb(img):
        assert img.mode == 'P', "image should be palette mode"
        pal = img.getpalette()
        colors = chunk(pal, 3, False)
        return colors


    pal = getPaletteInRgb(im)


    px = im.load()


    w, h = im.size


    if w != 160 or h != 144:
        raise Exception("image size does not match gb screen")


    unique_tiles = []
    unique_tile_count = 0


    def map_color(gif_palette_index):

        rgb = pal[gif_palette_index]

        if rgb == (242, 245, 235):
            return 0
        elif rgb == (251, 40, 84):
            return 3
        elif rgb == (8, 4, 23):
            return 2
        # I used different colors in a few sequences
        elif rgb == (152, 117, 124):
            return 1
        elif rgb == (95, 65, 71):
            return 1
        else:
            raise Exception("unexpected color in cutscene frame " + str(rgb))


    def encode_tile(x, y, map_file):
        tile_out = "DB      "
        tile_temp_1 = 0 # Pixel LSB
        tile_temp_2 = 0 # Pixel MSB

        count = 0

        for yy in range(y, y + 8):
            for xx in range(x, x + 8):

                pixel = map_color(px[xx, yy])

                tile_temp_1 = tile_temp_1 | ((pixel & 0x1) << (7 - count))
                tile_temp_2 = tile_temp_2 | (((pixel & 0x2) >> 1) << (7 - count))

                count = count + 1

                if count == 8:
                    tile_out += '${0:0{1}X}, '.format(tile_temp_1, 2)
                    tile_out += '${0:0{1}X}, '.format(tile_temp_2, 2)
                    count = 0
                    tile_temp_1 = 0
                    tile_temp_2 = 0

        map_data = ""
        if not tile_out in unique_tiles:
            map_data += '${0:0{1}X}, '.format(0x80 + len(unique_tiles), 2)
            unique_tiles.append(tile_out)
        else:
            map_data += '${0:0{1}X}, '.format(0x80 + unique_tiles.index(tile_out), 2)

        map_file.write(map_data)

    with open(map_data_file_name, "a") as map_file:
        map_file.write("." + fname_prefix + "_" + str(frame) + "\n")

    for y in range(0, 144, 8):
        with open(map_data_file_name, "a") as map_file:
            map_file.write("DB      ")
            for x in range(0, 160, 8):
                encode_tile(x, y, map_file)
            for i in range(0, 32 - 20):
                map_file.write("$00, ")
            map_file.write("\n")

    if len(unique_tiles) > 86:
        raise Exception("too many unique tiles in frame, excess " + str(-1 * (86 - len(unique_tiles))))

    print(len(unique_tiles))


    with open(texture_data_file_name, "a") as td_file:
        td_file.write("." + fname_prefix + "_" + str(frame) + "\n")

        tile_counts.append(len(unique_tiles))

        for tile in unique_tiles:
            td_file.write(tile)
            td_file.write("\n")


    frame += 1
